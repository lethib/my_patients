use axum::{
  debug_handler,
  extract::{Path, Query, State},
  http::status,
  Json,
};
use base64::Engine;
use sea_orm::{ColumnTrait, EntityTrait, ModelTrait, QueryFilter, QueryOrder};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct SearchBySSNParams {
  pub ssn: String,
}

#[derive(Deserialize)]
pub struct SearchParams {
  pub q: String,
  pub page: Option<u64>,
}

use crate::{
  app_state::AppState,
  auth::statement::AuthStatement,
  middleware::auth::AuthenticatedUser,
  models::{
    _entities::{medical_appointments, patients, practitioner_offices},
    my_errors::{application_error::ApplicationError, unexpected_error::UnexpectedError, MyErrors},
    patients::{CreatePatientParams, Model},
  },
  services::{self, invoice::GenerateInvoiceParams},
  views::{medical_appointments::MedicalAppointmentResponse, patient::PatientResponse},
};

#[debug_handler]
pub async fn get(
  State(state): State<AppState>,
  authorize: AuthStatement,
  Path(patient_id): Path<i32>,
) -> Result<Json<PatientResponse>, MyErrors> {
  let patient = patients::Entity::find_by_id(patient_id)
    .one(&state.db)
    .await?
    .ok_or(ApplicationError::NOT_FOUND())?;

  authorize
    .is_owning_resource(&patient)
    .await
    .run_complete()?;

  Ok(Json(PatientResponse::new(&patient)))
}

#[debug_handler]
pub async fn create(
  State(_state): State<AppState>,
  AuthenticatedUser(current_user, _): AuthenticatedUser,
  Json(create_patient_params): Json<CreatePatientParams>,
) -> Result<Json<serde_json::Value>, MyErrors> {
  services::patients::create(&create_patient_params, &current_user).await?;

  Ok(Json(serde_json::json!({ "success": true })))
}

#[debug_handler]
pub async fn update(
  State(state): State<AppState>,
  authorize: AuthStatement,
  Path(patient_id): Path<i32>,
  Json(patient_params): Json<CreatePatientParams>,
) -> Result<Json<serde_json::Value>, MyErrors> {
  let patient = patients::Entity::find_by_id(patient_id)
    .one(&state.db)
    .await?
    .ok_or(ApplicationError::NOT_FOUND())?;

  authorize
    .is_owning_resource(&patient)
    .await
    .run_complete()?;

  services::patients::update(&patient, &patient_params).await?;

  Ok(Json(serde_json::json!({ "success": true })))
}

#[debug_handler]
pub async fn delete(
  State(state): State<AppState>,
  authorize: AuthStatement,
  Path(patient_id): Path<i32>,
) -> Result<status::StatusCode, MyErrors> {
  let patient = patients::Entity::find_by_id(patient_id)
    .one(&state.db)
    .await?
    .ok_or(ApplicationError::NOT_FOUND())?;

  authorize
    .is_owning_resource(&patient)
    .await
    .run_complete()?;

  patient.delete(&state.db).await?;

  Ok(status::StatusCode::NO_CONTENT)
}

#[debug_handler]
pub async fn search_by_ssn(
  State(state): State<AppState>,
  Query(params): Query<SearchBySSNParams>,
) -> Result<Json<Vec<PatientResponse>>, MyErrors> {
  let found_patients = Model::search_by_ssn(&state.db, &params.ssn).await?;

  let serialized_patients: Vec<PatientResponse> = found_patients
    .iter()
    .map(|patient| PatientResponse::new(patient))
    .collect();

  Ok(Json(serialized_patients))
}

#[debug_handler]
pub async fn search(
  State(_state): State<AppState>,
  AuthenticatedUser(current_user, _): AuthenticatedUser,
  Query(params): Query<SearchParams>,
) -> Result<Json<serde_json::Value>, MyErrors> {
  let page = params.page.unwrap_or(1);

  let query = if params.q.trim().is_empty() {
    ""
  } else {
    &params.q
  };

  let (patients, total_pages) =
    services::patients::search_paginated(query, page, &current_user).await?;

  let patient_responses: Vec<PatientResponse> = patients
    .iter()
    .map(|p| PatientResponse::from_model(&p))
    .collect();

  Ok(Json(serde_json::json!({
    "paginated_data": patient_responses,
    "pagination": {
      "page": page,
      "per_page": 10,
      "total_pages": total_pages,
      "has_more": page < total_pages
    }
  })))
}

#[debug_handler]
pub async fn generate_invoice(
  State(state): State<AppState>,
  AuthenticatedUser(current_user, user_bi): AuthenticatedUser,
  Path(patient_id): Path<i32>,
  Json(params): Json<GenerateInvoiceParams>,
) -> Result<Json<serde_json::Value>, MyErrors> {
  if params.amount <= 0.0 {
    return Err(ApplicationError::UNPROCESSABLE_ENTITY());
  }

  if params.amount > (i32::MAX as f32 / 100.0) {
    return Err(ApplicationError::UNPROCESSABLE_ENTITY());
  }

  let invoice_generated =
    services::invoice::generate_patient_invoice(&patient_id, &params, &current_user).await?;

  if params.should_be_sent_by_email {
    match &user_bi {
      Some(business_information) => {
        services::invoice::send_invoice(
          &state,
          &invoice_generated,
          &current_user,
          business_information,
        )
        .await?
      }
      None => return Err(ApplicationError::UNPROCESSABLE_ENTITY()),
    }
  }

  Ok(Json(serde_json::json!({
    "pdf_data": base64::prelude::BASE64_STANDARD.encode(&invoice_generated.pdf_data),
    "filename": invoice_generated.filename
  })))
}

#[debug_handler]
pub async fn get_medical_appointments(
  State(state): State<AppState>,
  AuthenticatedUser(current_user, _): AuthenticatedUser,
  Path(patient_id): Path<i32>,
) -> Result<Json<Vec<MedicalAppointmentResponse>>, MyErrors> {
  let medical_appointments = medical_appointments::Entity::find()
    .filter(medical_appointments::Column::PatientId.eq(patient_id))
    .filter(medical_appointments::Column::UserId.eq(current_user.id))
    .order_by_desc(medical_appointments::Column::Date)
    .find_also_related(practitioner_offices::Entity)
    .all(&state.db)
    .await?
    .into_iter()
    .map(|appointment| {
      Ok(MedicalAppointmentResponse::new(
        &appointment.0,
        &appointment.1.ok_or(UnexpectedError::SHOULD_NOT_HAPPEN())?,
      ))
    })
    .collect::<Result<Vec<_>, MyErrors>>()?;

  Ok(Json(medical_appointments))
}
